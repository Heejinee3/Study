<br />

## useState

### 특징

- 함수형 컴포넌트 안에서 상태(state)를 관리
- 상태 변경 시 화면이 다시 렌더링됨

<br />

### 문법

```jsx
const [state, setState] = useState(initialValue);
```

`state` : 현재 상태 값

`setState` : 상태를 변경하는 함수

`initialValue` : 상태의 기본값

<br />

### 예제

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);
  return (
    <>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>+</button>
    </>
  );
}
```

<br />

## useEffect

### 특징

- 리액트 컴포넌트가 렌더링될 때마다 특정 작업을 수행하도록 설정
- componentDidMount, componentDidUpdate, componentWillUnmount 역할을 합쳐 놓은 것
- 정리(clean-up) 함수를 리턴 값으로 줄 수 있으며 언마운트나 의존성 변경 시 실행

<br />

### 문법

```jsx
useEffect(() => {
  // callback

  return () => {
    // clean-up
  };
}, [dependencies]);
```

`callback` : 실행할 함수

`clean-up` : 정리 작업

`dependencies` **:** 언제 실행할지 결정

<br />

### 예제

1. callback only, dependencies = []

`callback` : 마운트 시 실행

```jsx
useEffect(() => {
  console.log("Mount only");
}, []);
```

<br />

2. callback only, dependencies = [count]

`callback` : 마운트 + count 변경 시 실행

```jsx
useEffect(() => {
  console.log("Mount or count changed:", count);
}, [count]);
```

<br />

3. callback only, dependencies omitted

`callback` **:** 모든 렌더링마다 실행

```jsx
useEffect(() => {
  console.log("Every render");
});
```

<br />

4. callback + clean-up, dependencies = []

`callback` : 마운트 시 실행

`clean-up` : 언마운트 시 실행

```jsx
useEffect(() => {
  console.log("Mount");
  return () => console.log("Unmount");
}, []);
```

<br />

5. callback + clean-up, dependencies = [count]

`callback` : 마운트 + count 변경 시 실행

`clean-up` : 값 변경 전 + 언마운트 시 실행

```jsx
useEffect(() => {
  console.log("Mount or count changed:", count);
  return () => console.log("Clean-up before next effect or unmount");
}, [count]);
```

<br />

6. callback + clean-up, dependencies omitted

`callback` : 모든 렌더링마다 실행

`clean-up` : 이전 렌더링 clean-up

```jsx
useEffect(() => {
  console.log("Every render");
  return () => console.log("Clean-up before next render");
});
```

<br />

## useReducer

### 특징

- useState보다 복잡한 상태 로직을 다룰 때 유용
- 액션(action)과 리듀서 함수(reducer) 개념을 사용

<br />

### 문법

```jsx
const [state, dispatch] = useReducer(reducer, initialState);
```

`reducer` : `(state, action) => newState` 형태로, 현재 상태(state)와 액션(action)을 받아 새로운 상태 반환

`initialState` : 상태의 초기값

`state` : 현재 상태 값

`dispatch` : 액션을 발생시키는 함수

<br />

### 예제

```jsx
import { useReducer } from "react";

function reducer(state, action) {
  if (action.type === "TOGGLE") {
    return { on: !state.on };
  }
  return state;
}

function ToggleButton() {
  const [state, dispatch] = useReducer(reducer, { on: false });

  return (
    <button onClick={() => dispatch({ type: "TOGGLE" })}>
      {state.on ? "ON" : "OFF"}
    </button>
  );
}
```

<br />

## useMemo

### 특징

- 계산 비용이 큰 값을 메모이제이션(캐싱) 해서 불필요하게 다시 계산되지 않도록 하는 역할

<br />

### 문법

```jsx
const memoizedValue = useMemo(() => {
  return computeSomething();
}, [dependencies]);
```

`memoizedValue` : 캐싱된 값

`computeSomething` : 계산할 값

`dependencies` : 배열 안 값이 바뀔 때만 다시 계산됨

<br />

### 예제

```jsx
import { useState, useMemo } from "react";

function App() {
  const [count, setCount] = useState(0);

  const double = useMemo(() => {
    console.log("계산 실행!");
    return count * 2;
  }, [count]);

  return (
    <div>
      <p>Count: {count}</p>
      <p>Double: {double}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </div>
  );
}
```

<br />

## useCallback

### 특징

- 함수(Function)를 메모이제이션해서, 컴포넌트가 리렌더링될 때마다 새로 만들어지지 않도록 막아줌

<br />

### 문법

```jsx
const memoizedCallback = useCallback(() => {
  doSomething();
}, [dependencies]);
```

`memoizedCallback` : 캐싱된 함수

`doSomething` : 기억하고 싶은 함수

`dependencies` : 의존성이 바뀔 때만 새 함수 생성

<br />

### 예제

```jsx
import { useState, useCallback } from "react";

function App() {
  const [count, setCount] = useState(0);

  const handleClick = useCallback(() => {
    console.log("현재 count:", count);
  }, [count]);

  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
      <button onClick={handleClick}>로그</button>
    </div>
  );
}
```

<br />

## useRef

### 특징

- 컴포넌트가 리렌더링돼도 유지되는 값을 저장할 때 사용
- DOM 요소에 직접 접근할 때 사용
- ref.current 에 값이 저장됨
- 값이 바뀌어도 리렌더링 안 일어남

<br />

### 문법

```jsx
const ref = useRef(initialValue);
```

`ref` : 변수 이름

`initialValue` : 처음에 넣어줄 초기값

<br />

### 예제

1. DOM 접근

```jsx
import { useRef } from "react";

function App() {
  const inputRef = useRef(null);

  const focusInput = () => {
    inputRef.current.focus();
  };

  return (
    <div>
      <input ref={inputRef} type="text" />
      <button onClick={focusInput}>포커스</button>
    </div>
  );
}
```

<br />

2. 값 저장

```jsx
import { useRef, useState, useEffect } from "react";

function App() {
  const [count, setCount] = useState(0);
  const renderCount = useRef(0);

  useEffect(() => {
    renderCount.current += 1;
  });

  return (
    <div>
      <p>Count: {count}</p>
      <p>렌더링 횟수: {renderCount.current}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </div>
  );
}
```

<br />

## Custom Hook

### 특징

- React에서 내가 직접 만드는 Hook 함수
- 이름은 꼭 use로 시작 (useSomething)
- 여러 컴포넌트에서 반복되는 로직을 재사용하기 위해 사용
- 내부적으로 다른 Hook(useState, useEffect, useCallback 등)을 쓸 수 있음

<br />

### 예시

1. custom hook 만들기

```jsx
import { useState } from "react";

function useToggle(initialValue = false) {
  const [value, setValue] = useState(initialValue);

  const toggle = () => setValue((prev) => !prev);

  return [value, toggle];
}

export default useToggle;
```

<br />

2. 사용하기

```jsx
import useToggle from "./useToggle";

function App() {
  const [isOpen, toggleOpen] = useToggle();

  return (
    <div>
      <p>{isOpen ? "열림 ✅" : "닫힘 ❌"}</p>
      <button onClick={toggleOpen}>토글</button>
    </div>
  );
}

export default App;
```

<br />
<br />
<br />
<br />
