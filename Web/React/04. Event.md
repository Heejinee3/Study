<br />

## Event

- 사용자 동작(클릭, 입력, 마우스 이동 등)에 반응하는 함수 실행 방식
- 브라우저의 이벤트를 그대로 쓰는 게 아니라, React가 제공하는 SyntheticEvent(합성 이벤트)라는 래퍼 객체를 통해 브라우저마다 차이를 없애고 통일된 방식으로 동작
- camelCase 이름 사용하며 문자열이 아니라 함수를 전달

<br />

## Class Component

### 기본

```jsx
class App extends Component {
  state = { count: 0 };

  // 화살표 함수를 사용하면 bind가 필요 없음
  handleClick = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return <button onClick={this.handleClick}>{this.state.count}</button>;
  }
}
```

```jsx
class App extends Component {
  state = { count: 0 };

  render() {
    return (
      <button onClick={() => this.setState({ count: this.state.count + 1 })}>
        {this.state.count}
      </button>
    );
  }
}
```

<br />

### constructor 안에서 bind 하는 경우

```jsx
class App extends Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };

    // handleClick 내부의 this를 항상 현재 컴포넌트(App) 인스턴스로 고정
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    this.setState({ count: this.state.count + 1 });
  }

  render() {
    return <button onClick={this.handleClick}>{this.state.count}</button>;
  }
}
```

<br />

### render 안에서 bind 하는 경우

```jsx
class App extends Component {
  state = { count: 0 };

  handleClick() {
    this.setState({ count: this.state.count + 1 });
  }

  render() {
    // 매 렌더링마다 새 함수가 생성되므로 성능에 좋지 않음
    return (
      <button onClick={this.handleClick.bind(this)}>{this.state.count}</button>
    );
  }
}
```

<br />

### 파라미터가 있는 경우

```jsx
class App extends Component {
  state = { message: "" };

  handleClick = (msg) => {
    this.setState({ message: msg });
  };

  render() {
    // onClick={this.handleClick("안녕하세요")} 이렇게 쓰면 즉시 실행되므로 반드시 화살표 함수로 감싸야 함
    return (
      <div>
        <button onClick={() => this.handleClick("안녕하세요")}>Hello</button>
        <button onClick={() => this.handleClick("잘가요")}>Bye</button>
        <p>{this.state.message}</p>
      </div>
    );
  }
}
```

<br />

### event 객체를 사용할 경우

```jsx
class App extends Component {
  state = { message: "" };

  handleClick = (event) => {
    console.log(event);
    this.setState({ message: "버튼 클릭!" });
  };

  render() {
    return (
      <div>
        <button onClick={this.handleClick}>Hello</button>
        <button onClick={this.handleClick}>Bye</button>
        <p>{this.state.message}</p>
      </div>
    );
  }
}
```

```jsx
class App extends Component {
  state = { message: "" };

  handleClick = (msg, event) => {
    console.log(event);
    this.setState({ message: msg });
  };

  render() {
    return (
      <div>
        <button onClick={(e) => this.handleClick("안녕하세요", e)}>
          Hello
        </button>
        <button onClick={(e) => this.handleClick("잘가요", e)}>Bye</button>
        <p>{this.state.message}</p>
      </div>
    );
  }
}
```

<br />

## Functional Component

```jsx
function App() {
  const [count, setCount] = useState(0);

  // 함수형에서는 bind 필요 없음
  const handleClick = () => setCount(count + 1);

  return <button onClick={handleClick}>{count}</button>;
}
```

```jsx
function App() {
  const [count, setCount] = useState(0);

  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

<br />
<br />
<br />
<br />
