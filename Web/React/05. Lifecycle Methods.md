<br />

## Mount

컴포넌트가 처음 생성되어 DOM에 추가되는 순간

<p></p>

`constructor(props)` : state 초기화

→ `getDerivedStateFromProps(nextProps, prevState)` : props 기반으로 state 동기화

→ `render()` : JSX 그리기

→ `componentDidMount()` : DOM 완성 후 실행

<br />

---

### componentDidMount()

- 마운트 완료 후 1번만 실행됨
- 이 시점에는 DOM이 이미 만들어져 있어 DOM 조작 가능
- 비동기 작업(API 요청, setTimeout, 이벤트 등록 등)에 자주 사용

<br />

### getDerivedStateFromProps(nextProps, prevState)

- static getDerivedStateFromProps(props, state) 형태
- props 변화에 따라 state를 동기화해야 할 때 사용
- 정적 메서드이기 때문에 this에 접근할 수 없음
- 항상 객체(state 변경값)나 null을 반환해야 함
- 너무 남용하면 state와 props가 중복 관리돼서 복잡해지기 때문에 필요할때만 사용
- 함수형 컴포넌트에서는 useEffect로 대체 가능

```jsx
class App extends Component {
  state = { value: "" };

  // props가 바뀌면 state도 맞춰 바꿔줌
  static getDerivedStateFromProps(nextProps, prevState) {
    if (nextProps.defaultValue !== prevState.value) {
      return { value: nextProps.defaultValue };
    }
    return null; // 바꿀 필요 없으면 null
  }

  render() {
    return <input value={this.state.value} readOnly />;
  }
}

// 사용
<App defaultValue="Hello" />;
```

<br />

## Update

컴포넌트의 state나 props가 바뀌거나, 부모 컴포넌트가 리렌더링되거나, `this.forceUpdate()`가 호출될 때 화면이 다시 렌더링되는 과정

<p></p>

`getDerivedStateFromProps(nextProps, prevState)` **:** props 기반으로 state 동기화

→ `shouldComponentUpdate(nextProps, nextState)` : 렌더링 여부 결정

→ `render()` : JSX 그리기

→ `getSnapshotBeforeUpdate(prevProps, prevState)` : 업데이트 직전 DOM 상태 확인 → 스크롤 위치 등 저장 가능

→ `componentDidUpdate(prevProps, prevState, snapshot)` : 업데이트 후 실행

<br />

---

### shouldComponentUpdate(nextProps, nextState)

- 리턴값에 따라 렌더링 결정
  - true → render() 실행
  - false → 렌더링 건너뜀
- 매개변수 nextProps, nextState로 새로운 props와 state 확인 가능

```jsx
class App extends Component {
  state = { count: 0 };

  shouldComponentUpdate(nextProps, nextState) {
    return nextState.count % 2 === 0;
  }

  render() {
    return (
      <>
        <p>{this.state.count}</p>
        <button onClick={() => this.setState({ count: this.state.count + 1 })}>
          +
        </button>
      </>
    );
  }
}
```

<br />

### getSnapshotBeforeUpdate(prevProps, prevState)

- 클래스형 컴포넌트의 업데이트 단계에서, DOM이 실제로 바뀌기 직전에 정보를 캡처
- 반환값은 componentDidUpdate의 세 번째 매개변수 snapshot으로 전달됨

```jsx
class App extends Component {
  listRef = React.createRef();

  getSnapshotBeforeUpdate(prevProps, prevState) {
    // 업데이트 전 스크롤 위치 저장
    return this.listRef.current.scrollHeight;
  }

  componentDidUpdate(prevProps, prevState, snapshot) {
    console.log("업데이트 전 스크롤 높이:", snapshot);
  }

  render() {
    return (
      <div ref={this.listRef}>
        <p>{this.props.text}</p>
      </div>
    );
  }
}
```

<br />

### componentDidUpdate(prevProps, prevState, snapshot)

- DOM이 실제로 업데이트된 직후 실행
- 매개변수
  - prevProps: 이전 props
  - prevState: 이전 state
  - snapshot: getSnapshotBeforeUpdate에서 반환한 값, 선택적
- 네트워크 요청, DOM 조작, 로그 출력 등을 많이 함

<br />

## Unmount

컴포넌트가 화면(DOM)에서 제거되는 과정

<p></p>

`componentWillUnmount()` : DOM에서 제거되기 전 실행

<br />

---

### componentWillUnmount()

- 컴포넌트가 DOM에서 제거되기 전에 한 번 실행됨
- 정리 작업(이벤트 리스너 제거, 타이머/인터벌 정리, 네트워크 요청 취소 등)을 하는 곳

<br />

## 에러 잡기

### componentDidCatch(error, info)

- 클래스형 컴포넌트에서 에러를 잡기 위한 라이프사이클 메서드
- 매개변수
  - error: 실제 에러 객체
  - info: 어떤 컴포넌트에서 발생했는지 정보
- 자식 컴포넌트에서 발생한 에러만 잡음
  - 자기 자신 내부의 이벤트 핸들러 같은 런타임 에러는 못 잡음 (try/catch 써야 함)
- 보통 에러 바운더리(Error Boundary) 컴포넌트에서 사용

```jsx
class ErrorBoundary extends Component {
  state = { hasError: false };

  componentDidCatch(error, info) {
    console.log("에러 발생:", error);
    console.log("에러 정보:", info);
    this.setState({ hasError: true });
  }

  render() {
    if (this.state.hasError) {
      return <h1>무언가 잘못됐습니다.</h1>;
    }
    return this.props.children;
  }
}

class Buggy extends React.Component {
  render() {
    throw new Error("버그 발생!");
  }
}

class App extends React.Component {
  render() {
    return (
      <ErrorBoundary>
        <Buggy />
      </ErrorBoundary>
    );
  }
}
```

<br />
<br />
<br />
<br />
