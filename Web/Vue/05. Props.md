<br />

## Props

- 부모 컴포넌트가 자식 컴포넌트에 데이터를 전달할 때 사용하는 방법

```html
<!-- Parent.vue -->
<template>
  <Child :message="parentMessage" />
</template>

<script setup>
  import Child from "./Child.vue";

  const parentMessage = "Hello from Parent";
</script>
```

```html
<!-- Child.vue -->
<template>
  <div>
    <p>{{ message }}</p>
  </div>
</template>

<script setup>
  defineProps({
    message: String,
  });
</script>
```

<br />

## 옵션

| 옵션      | 설명                                                                                     | 예시                                                   |
| --------- | ---------------------------------------------------------------------------------------- | ------------------------------------------------------ |
| type      | prop의 타입을 지정                                                                       | type: String, type: [String, Number]                   |
| default   | prop이 전달되지 않았을 때 사용할 기본값을 지정 (객체나 배열은 팩토리 함수로 반환해야 함) | default: 'Hello', default: () => []                    |
| required  | prop이 필수인지 여부를 정의                                                              | required: true                                         |
| validator | prop 값에 대한 커스텀 유효성 검사를 위한 함수                                            | validator(value) { return value.startsWith('Hello'); } |

```html
<!-- Parent.vue -->
<template>
  <Child :message="message" :items="items" />
</template>

<script setup>
  import { ref } from "vue";
  import Child from "./Child.vue";

  const message = ref("Hello, World"); // 'Hello'로 시작하지 않으면 경고 발생
  const items = ref([1, "two", 3]); // 배열에 숫자가 아닌 값이 포함되어 있으면 경고 발생
</script>
```

```html
<!-- Child.vue -->
<template>
  <div>
    <p>{{ message }}</p>
    <p>{{ items }}</p>
  </div>
</template>

<script setup>
  const props = defineProps({
    message: {
      type: String,
      default: "Default message",
      required: true,
      validator(value) {
        if (!value.startsWith("Hello")) {
          console.warn('Message should start with "Hello"');
          return false;
        }
        return true;
      },
    },
    items: {
      type: Array,
      default: () => [], // 객체나 배열은 함수 형태로 반환
      validator(value) {
        if (!value.every((item) => typeof item === "number")) {
          console.warn("Each item in the array should be a number");
          return false;
        }
        return true;
      },
    },
  });
</script>
```

<br />

## Emit

- 자식에서 props 값을 직접 변경하면 Vue가 경고를 띄움
- 만약 수정이 필요하면 emit을 통해 부모에 알려줘야 함
- 이벤트 명은 update:prop 형식을 써야 함

```html
<!-- Parent.vue -->
<template>
  <Child :message="parentMessage" @update:message="parentMessage = $event" />
  <!-- $emit으로 커스텀 이벤트를 발생시켜서 파라미터를 넘겼다면, $event는 그 전달된 값 자체가 됨 -->
</template>

<script setup>
  import { ref } from "vue";
  import Child from "./Child.vue";

  const parentMessage = ref("Hello from Parent");
</script>
```

```html
<!-- Child.vue -->
<template>
  <div>
    <p>{{ message }}</p>
    <button @click="changeMessage">Change Message</button>
  </div>
</template>

<script setup>
  const props = defineProps({
    message: String,
  });

  const emit = defineEmits(["update:message"]); // event name은 'update:prop' 형식을 써야 함

  const changeMessage = () => {
    emit("update:message", "Hello from Child!"); // emit(event name, parameter1, parameter2, ...)
  };
</script>
```

<br />

## v-model

- 부모-자식 컴포넌트 간 양방향 바인딩
- 기본적으로 prop 명은 modelValue, event 명은 update:modelValue 를 써야 함

```html
<!-- Parent.vue -->
<template>
  <div>
    <Child v-model="message" />
    <p>부모가 가진 message: {{ message }}</p>
  </div>
</template>

<script setup>
  import { ref } from "vue";
  import Child from "./Child.vue";

  const message = ref("Hello from parent!");
</script>
```

```html
<!-- Child.vue -->
<template>
  <div>
    <input
      :value="modelValue"
      @input="$emit('update:modelValue', $event.target.value)"
    />
    <!-- $event.target = event가 발생한 실제 DOM 요소 -->
    <p>자식이 받은 modelValue: {{ modelValue }}</p>
  </div>
</template>

<script setup>
  defineProps({
    modelValue: String,
  });

  defineEmits(["update:modelValue"]);
</script>
```

<p></p>

- computed를 활용해서 조금 더 깔끔하게 v-model을 구현 가능

```html
<!-- Parent.vue -->
<template>
  <div>
    <Child v-model="message" />
    <p>부모가 가진 message: {{ message }}</p>
  </div>
</template>

<script setup>
  import { ref } from "vue";
  import Child from "./Child.vue";

  const message = ref("Hello from parent!");
</script>
```

```html
<!-- Child.vue -->
<template>
  <div>
    <input v-model="localModel" />
    <p>자식이 받은 modelValue: {{ modelValue }}</p>
  </div>
</template>

<script setup>
  import { computed } from "vue";

  const props = defineProps({
    modelValue: String,
  });

  const emit = defineEmits(["update:modelValue"]);

  // computed를 사용해서 getter/setter 연결
  const localModel = computed({
    get() {
      return props.modelValue;
    },
    set(value) {
      emit("update:modelValue", value);
    },
  });
</script>
```

<p></p>

- 여러 개의 v-model을 사용하려면, modelValue와 update:modelValue 외에도 v-model 이름을 다르게 지정해야 함
- 이를 위해 v-model:propName을 사용하고, 자식 컴포넌트에서는 해당 prop에 맞는 update:propName 이벤트를 emit하면 됨

```html
<!-- Parent.vue -->
<template>
  <div>
    <Child v-model:title="title" v-model:description="description" />
    <p>부모가 가진 title: {{ title }}</p>
    <p>부모가 가진 description: {{ description }}</p>
  </div>
</template>

<script setup>
  import { ref } from "vue";
  import Child from "./Child.vue";

  const title = ref("부모의 제목");
  const description = ref("부모의 설명");
</script>
```

```html
<!-- Child.vue -->
<template>
  <div>
    <input
      :value="title"
      @input="$emit('update:title', $event.target.value)"
      placeholder="제목을 입력하세요"
    />
    <p>자식이 받은 title: {{ title }}</p>

    <input
      :value="description"
      @input="$emit('update:description', $event.target.value)"
      placeholder="설명을 입력하세요"
    />
    <p>자식이 받은 description: {{ description }}</p>
  </div>
</template>

<script setup>
  defineProps({
    title: String,
    description: String,
  });

  defineEmits(["update:title", "update:description"]);
</script>
```

<p></p>

- v-model의 수식어(modifiers)는 양방향 바인딩 시 입력 값의 처리 방식을 미세 조정할 수 있도록 도와줌
  | 수식어 | 설명 |
  | --------- | ---------------------------------------------------------- |
  | .lazy | input 이벤트 대신 change 이벤트를 사용해 값을 업데이트 |
  | .number | 입력 값을 자동으로 숫자로 변환 (parseFloat) |
  | .trim | 입력 양 끝의 공백을 제거한 후 반영 |
- 컴포넌트에서 수식어를 처리하려면 modelModifiers라는 prop을 통해 전달받음
- modelModifiers는 Vue가 자동으로 컴포넌트에 주입하는 특별한 prop이므로 defineProps로 명시해주어야 함
- modelModifiers는 객체 형태이며, 사용된 수식어 이름이 true로 표시됨
- v-model.number.trim은 일반 HTML &lt;input&gt;에만 자동 동작하고, 커스텀 컴포넌트에서는 Vue가 수식어 정보를 modelModifiers로 넘겨줄 뿐, 실제 .trim이나 .number 처리는 컴포넌트가 직접 구현해야함

```html
<!-- Parent.vue -->
<template>
  <Child v-model.number.trim="age" />
</template>

<script setup>
  import { ref } from "vue";
  import Child from "./Child.vue";

  const age = ref("");
</script>
```

```html
<!-- Child.vue -->
<script setup>
  const props = defineProps({
    modelValue: [String, Number],
    modelModifiers: Object,
  });

  const emit = defineEmits(["update:modelValue"]);

  function onInput(e) {
    let value = e.target.value;

    if (props.modelModifiers.trim) {
      value = value.trim();
    }
    if (props.modelModifiers.number) {
      value = parseFloat(value);
      if (isNaN(value)) value = "";
    }

    emit("update:modelValue", value);
  }
</script>

<template>
  <input :value="modelValue" @input="onInput" />
</template>
```

<p></p>

<details>
  <summary>Vue 2 에서의 양방향 바인딩</summary>

```html
<!-- Parent.vue -->
<template>
  <Child :message="message" @update:message="message = $event" />
</template>

<script>
  export default {
    components: { Child },
    data() {
      return {
        message: "Hello from Parent",
      };
    },
  };
</script>
```

```html
<!-- Child.vue -->
<template>
  <button @click="changeMessage">Change Message</button>
</template>

<script>
  export default {
    props: {
      message: String,
    },
    methods: {
      changeMessage() {
        this.$emit("update:message", "New Message");
      },
    },
  };
</script>
```

</details>

<br />
<br />
<br />

[출처: 짐코딩, 「Vue3 완벽 마스터: 기초부터 실전까지 - "기본편"」, 인프런](https://www.inflearn.com/course/vue-%EC%99%84%EB%B2%BD-%EA%B8%B0%EB%B3%B8)

<br />
